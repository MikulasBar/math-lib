// parser generated by Antlr4Rust: "https://github.com/rrevenantt/antlr4rust"
#![allow(unused)]

mod mathlexer;
mod mathparser;
mod mathlistener;
mod mathvisitor;

use antlr_rust::{
    common_token_stream::CommonTokenStream, tree::{ParseTree, ParseTreeListener, ParseTreeVisitorCompat, VisitChildren}, InputStream
};

use self::{
    mathlexer::*,
    mathparser::*,
    mathlistener::*,
    mathvisitor::*,
};
use crate::functions::*;



struct MathVisitor(f64);

impl ParseTreeVisitorCompat<'_> for MathVisitor {
    type Node = mathParserContextType;
    type Return = f64;

    fn temp_result(&mut self) -> &mut Self::Return {
        &mut self.0
    }

    fn aggregate_results(&self, aggregate: Self::Return, next: Self::Return) -> Self::Return {
        todo!()
    }
}

impl mathVisitorCompat<'_> for MathVisitor {
    fn visit_prog(&mut self, ctx: &ProgContext<'_>) -> Self::Return {
        self.visit(&*ctx.expr().unwrap())
    }

    fn visit_number(&mut self, ctx: &NumberContext<'_>) -> Self::Return {
        ctx.NUMBER().unwrap().get_text().parse().unwrap()
    }

    fn visit_parens(&mut self, ctx: &ParensContext<'_>) -> Self::Return {
        self.visit(&*ctx.expr().unwrap())
    }

    fn visit_add(&mut self, ctx: &AddContext<'_>) -> Self::Return {
        let a = self.visit(&*ctx.expr(0).unwrap());
        let b = self.visit(&*ctx.expr(1).unwrap());

        if ctx.ADD().is_some() {
            return a + b
        }
        a - b
    }

    fn visit_multiply(&mut self, ctx: &MultiplyContext<'_>) -> Self::Return {
        let a = self.visit(&*ctx.expr(0).unwrap());
        let b = self.visit(&*ctx.expr(1).unwrap());

        if ctx.MUL().is_some() {
            return a * b
        }
        a / b
    }

    fn visit_power(&mut self, ctx: &PowerContext<'_>) -> Self::Return {
        let a = self.visit(&*ctx.expr(0).unwrap());
        let b = self.visit(&*ctx.expr(1).unwrap());
        a.powf(b)
    }

    fn visit_function(&mut self, ctx: &FunctionContext<'_>) -> Self::Return {
        let arg = self.visit(&*ctx.expr().unwrap());
        todo!()
    }
}

// --> see listener and visitor on https://github.com/rrevenantt/antlr4rust/blob/master/tests/visitors_tests.rs

// #[should_panic]
#[test]
fn test_parser() {
    let lexer = mathLexer::new(InputStream::new("4 * 2 - 6 / 3".into()));

    let token_source = CommonTokenStream::new(lexer);
    let mut parser = mathParser::new(token_source);

    let root = parser.prog().unwrap();

    let result = MathVisitor(0.0).visit(&*root);
    assert_eq!(result, 6.0);

}

#[test]
fn test_visitor() {
    let mut _lexer = mathLexer::new(InputStream::new("2 + 8 / 2".into()));
    let token_source = CommonTokenStream::new(_lexer);
    let mut parser = mathParser::new(token_source);

    let root = parser.prog().unwrap();

    assert_eq!(
        "(s (expr (expr 2) + (expr (expr 8) / (expr 2))) <EOF>)",
        root.to_string_tree(&*parser)
    );
    
    let mut visitor = MathVisitor(0.0);

    let visitor_result = visitor.visit(&*root);
    assert_eq!(6.0, visitor_result)

}
