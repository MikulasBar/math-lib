<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Better Any"><title>better_any - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="better_any" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../better_any/index.html">better_any</a><span class="version">0.2.0</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../better_any/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">better_any</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/better_any/lib.rs.html#1-592">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="better-any"><a href="#better-any">Better Any</a></h2>
<p>Rust RFC for <code>non_static_type_id</code> feature has been reverted.
Which means in foreseeable future there will be no built-in way in rust to get type id for non-static type
let alone safely use it to downcast to a particular type.</p>
<p>This crate provides tools to do these things safely for types with single lifetime.
Although looks like it is technically possible to extend this approach for multiple lifetimes,
consistent api and derive macro would be much harder to create and use because of the necessity
to properly handle lifetime relations.
Feel free to create an issue if you have actual use case where you need this functionality for multiple lifetimes.</p>
<p>Also it has better downcasting that allows you do downcast not just from <code>dyn Tid</code> (like <code>dyn Any</code>) but from
any trait object that implements <a href="trait.Tid.html" title="trait better_any::Tid"><code>Tid</code></a>.
So there is no more need to extend your traits with<code> fn to_any(&amp;self)-&gt; &amp;dyn Any</code></p>
<p>MSRV: <code>1.41.0-stable</code> (without nightly feature)</p>
<h4 id="usage"><a href="#usage">Usage</a></h4>
<p>Basically in places where before you have used <code>dyn Any</code> you can use <code>dyn Tid&lt;'a&gt;</code></p>
<ul>
<li>If your type is generic you should derive <code>Tid</code> implementation for it with <code>tid!</code> macro or <code>Tid</code> derive macro.
Then to retrieve back concrete type <code>&lt;dyn Tid&gt;::downcast_*</code> methods should be used.</li>
<li>If your type is not generic/implements Any you can create <code>dyn Tid</code> from it via any of the available <code>From</code> implementations.
Then to retrieve back concrete type <code>&lt;dyn Tid&gt;::downcast_any_*</code> methods should be used</li>
<li>If your type is not generic and local to your crate you also can derive <code>Tid</code> but then you need to be careful
to use methods that corresponds to the way you create <code>dyn Tid</code> for that particular type.
Otherwise downcasting will return <code>None</code>.</li>
</ul>
<p>If all your types can implement <code>Tid</code> to avoid confusion
recommended way is to use first option even if some types implement <code>Any</code>.
If there are some types that implement <code>Any</code> and can’t implement <code>Tid</code> (i.e. types from other library),
recommended way is to use second option for all types that implement <code>Any</code> to reduce confusion to minimum.</p>
<h4 id="interoperability-with-any"><a href="#interoperability-with-any">Interoperability with Any</a></h4>
<p>Unfortunately you can’t just use <code>Tid</code> everywhere because currently it is impossible
to implement <code>Tid</code> for <code>T:Any</code> since it would conflict with any other possible <code>Tid</code> implementation.
To overcome this limitation there is a <code>From</code> impl to go from <code>Box/&amp;/&amp;mut T where T:Any</code> to <code>Box/&amp;/&amp;mut dyn Tid</code>.</p>
<p>Nevertheless if you are using <code>dyn Trait</code> where <code>Trait:Tid</code> all of this wouldn’t work,
and you are left with <code>Tid</code> only.</p>
<h4 id="safety"><a href="#safety">Safety</a></h4>
<p>It is safe because created trait object preserves lifetime information,
thus allowing us to safely downcast with proper lifetime.
Otherwise internally it is plain old <code>Any</code>.</p>
</div></details><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.tid.html" title="macro better_any::tid">tid</a></div><div class="desc docblock-short">Main safe implementation interface of related unsafe traits</div></li><li><div class="item-name"><a class="macro" href="macro.type_id.html" title="macro better_any::type_id">type_id</a></div><div class="desc docblock-short">Just an alias of <code>tid!</code> macro if someone considers that name to be more clear and for compatibility with previous versions.</div></li></ul><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AnyExt.html" title="trait better_any::AnyExt">AnyExt</a></div><div class="desc docblock-short">Methods here are implemented as an associated functions because otherwise
for one they will conflict with methods defined on <code>dyn Any</code> in stdlib,
for two they will be available on almost every type in the program causing confusing bugs and error messages
For example if you have <code>&amp;Box&lt;dyn Any&gt;</code> and call <code>downcast_ref</code>, instead of failing or working on coerced <code>&amp;dyn Any</code>
it would work with type id of <code>Box&lt;dyn Any&gt;</code> itself instead of the type behind <code>dyn Any</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Tid.html" title="trait better_any::Tid">Tid</a></div><div class="desc docblock-short">This trait indicates that this type can be converted to
trait object with typeid while preserving lifetime information.
Extends <code>Any</code> functionality for types with single lifetime</div></li><li><div class="item-name"><a class="trait" href="trait.TidAble.html" title="trait better_any::TidAble">TidAble</a></div><div class="desc docblock-short">This trait indicates that you can substitute this type as a type parameter to
another type so that resulting type could implement <code>Tid</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.TidExt.html" title="trait better_any::TidExt">TidExt</a></div><div class="desc docblock-short">Extension trait that contains actual downcasting methods.</div></li></ul><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.typeid_of.html" title="fn better_any::typeid_of">typeid_of</a></div><div class="desc docblock-short">Returns type id of <code>T</code></div></li></ul></section></div></main></body></html>